#!/bin/bash
# Turing Smart Screen Installation Script for Arch Linux
# 
# Usage:
#   ./install.sh              # Interactive installation
#   ./install.sh --uninstall  # Remove installation
#   ./install.sh --detect     # Only detect and configure USB ports

set -euo pipefail

INSTALL_DIR="/usr/local/bin"
UDEV_DIR="/etc/udev/rules.d"
SYSTEMD_DIR="/etc/systemd/system"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() { echo -e "${BLUE}[INFO]${NC} $*"; }
log_success() { echo -e "${GREEN}[OK]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*"; }

# Check if running as root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        log_error "This script must be run as root (use sudo)"
        exit 1
    fi
}

# Detect Turing Smart Screen devices
detect_devices() {
    log_info "Detecting Turing Smart Screen devices..."
    
    local devices=()
    for dev in /dev/ttyACM*; do
        [[ -e "$dev" ]] || continue
        
        # Check if it's a CH340 device (Turing Smart Screen)
        if udevadm info -a -n "$dev" 2>/dev/null | grep -q 'ATTRS{idVendor}=="1a86"'; then
            if udevadm info -a -n "$dev" 2>/dev/null | grep -q 'ATTRS{idProduct}=="7523"'; then
                devices+=("$dev")
            fi
        fi
    done
    
    if [[ ${#devices[@]} -eq 0 ]]; then
        log_warn "No Turing Smart Screen devices found"
        log_info "Make sure devices are connected via USB"
        return 1
    fi
    
    log_success "Found ${#devices[@]} device(s):"
    for dev in "${devices[@]}"; do
        local kernel_path
        kernel_path=$(udevadm info -q path -n "$dev" | grep -oE '[0-9]+-[0-9.]+' | head -1)
        echo "  $dev -> USB port: $kernel_path"
    done
    
    echo
    printf '%s\n' "${devices[@]}"
}

# Interactive USB port assignment
configure_udev() {
    local devices=()
    while IFS= read -r line; do
        devices+=("$line")
    done < <(detect_devices | tail -n +4)
    
    if [[ ${#devices[@]} -eq 0 ]]; then
        return 1
    fi
    
    echo
    log_info "Configure which display shows which monitor:"
    echo
    
    local cpu_port="" ram_port="" agent_port=""
    local monitors=("cpu" "ram" "agent")
    local monitor_names=("CPU Monitor (htop-style)" "RAM Monitor (memory usage)" "Agent Monitor (coding agents)")
    
    for i in "${!monitors[@]}"; do
        echo "Available devices for ${monitor_names[$i]}:"
        for j in "${!devices[@]}"; do
            local dev="${devices[$j]}"
            local kernel_path
            kernel_path=$(udevadm info -q path -n "$dev" | grep -oE '[0-9]+-[0-9.]+' | head -1)
            echo "  $((j+1))) $dev (USB port: $kernel_path)"
        done
        echo "  s) Skip this monitor"
        echo
        
        while true; do
            read -rp "Select device for ${monitors[$i]} [1-${#devices[@]}/s]: " choice
            
            if [[ "$choice" == "s" ]]; then
                break
            elif [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= ${#devices[@]} )); then
                local selected_dev="${devices[$((choice-1))]}"
                local kernel_path
                kernel_path=$(udevadm info -q path -n "$selected_dev" | grep -oE '[0-9]+-[0-9.]+' | head -1)
                
                case "${monitors[$i]}" in
                    cpu) cpu_port="$kernel_path" ;;
                    ram) ram_port="$kernel_path" ;;
                    agent) agent_port="$kernel_path" ;;
                esac
                
                log_success "Assigned $selected_dev (port $kernel_path) to ${monitors[$i]}"
                break
            else
                log_error "Invalid choice"
            fi
        done
        echo
    done
    
    # Generate udev rules
    generate_udev_rules "$cpu_port" "$ram_port" "$agent_port"
}

# Generate udev rules file
generate_udev_rules() {
    local cpu_port="$1" ram_port="$2" agent_port="$3"
    
    log_info "Generating udev rules..."
    
    cat > "${UDEV_DIR}/99-turing-lcd.rules" << 'HEADER'
# Turing Smart Screen LCD udev rules
# Generated by install.sh
#
# Symlinks created:
#   /dev/lcd-cpu    - CPU monitor display
#   /dev/lcd-ram    - RAM monitor display
#   /dev/lcd-agent  - Agent status display

SUBSYSTEM!="tty", GOTO="turing_lcd_end"
ATTRS{idVendor}!="1a86", GOTO="turing_lcd_end"
ATTRS{idProduct}!="7523", GOTO="turing_lcd_end"

HEADER
    
    if [[ -n "$cpu_port" ]]; then
        echo "KERNELS==\"$cpu_port\", SYMLINK+=\"lcd-cpu\", MODE=\"0666\"" >> "${UDEV_DIR}/99-turing-lcd.rules"
    fi
    if [[ -n "$ram_port" ]]; then
        echo "KERNELS==\"$ram_port\", SYMLINK+=\"lcd-ram\", MODE=\"0666\"" >> "${UDEV_DIR}/99-turing-lcd.rules"
    fi
    if [[ -n "$agent_port" ]]; then
        echo "KERNELS==\"$agent_port\", SYMLINK+=\"lcd-agent\", MODE=\"0666\"" >> "${UDEV_DIR}/99-turing-lcd.rules"
    fi
    
    echo >> "${UDEV_DIR}/99-turing-lcd.rules"
    echo 'LABEL="turing_lcd_end"' >> "${UDEV_DIR}/99-turing-lcd.rules"
    
    log_success "Created ${UDEV_DIR}/99-turing-lcd.rules"
    
    # Reload udev rules
    udevadm control --reload-rules
    udevadm trigger
    
    log_success "udev rules reloaded"
    
    # Verify symlinks
    sleep 1
    echo
    log_info "Verifying symlinks:"
    for link in /dev/lcd-cpu /dev/lcd-ram /dev/lcd-agent; do
        if [[ -L "$link" ]]; then
            log_success "$link -> $(readlink -f "$link")"
        fi
    done
}

# Install binary
install_binary() {
    log_info "Installing binary..."
    
    local binary=""
    
    # Check for local binary first
    if [[ -x "${SCRIPT_DIR}/../turing-screens" ]]; then
        binary="${SCRIPT_DIR}/../turing-screens"
    elif [[ -x "${SCRIPT_DIR}/../screens" ]]; then
        binary="${SCRIPT_DIR}/../screens"
    elif [[ -x "./turing-screens" ]]; then
        binary="./turing-screens"
    fi
    
    if [[ -z "$binary" ]]; then
        log_info "No local binary found, downloading latest release..."
        
        local arch
        arch=$(uname -m)
        case "$arch" in
            x86_64) arch="amd64" ;;
            aarch64) arch="arm64" ;;
            *) log_error "Unsupported architecture: $arch"; exit 1 ;;
        esac
        
        local url="https://github.com/aleksclark/go-turing-smart-screen/releases/latest/download/turing-screens-linux-${arch}"
        
        log_info "Downloading from $url..."
        if command -v curl &>/dev/null; then
            curl -fsSL -o /tmp/turing-screens "$url"
        elif command -v wget &>/dev/null; then
            wget -qO /tmp/turing-screens "$url"
        else
            log_error "Neither curl nor wget found"
            exit 1
        fi
        
        binary="/tmp/turing-screens"
    fi
    
    install -m 755 "$binary" "${INSTALL_DIR}/turing-screens"
    log_success "Installed ${INSTALL_DIR}/turing-screens"
}

# Install systemd service
install_service() {
    log_info "Installing systemd service..."
    
    # Build ExecStart line based on available symlinks
    local exec_args="--brightness 30"
    
    if [[ -L /dev/lcd-cpu ]]; then
        exec_args+=" --cpu-port /dev/lcd-cpu"
    else
        exec_args+=" --no-cpu"
    fi
    
    if [[ -L /dev/lcd-ram ]]; then
        exec_args+=" --ram-port /dev/lcd-ram"
    else
        exec_args+=" --no-ram"
    fi
    
    if [[ -L /dev/lcd-agent ]]; then
        exec_args+=" --agent-port /dev/lcd-agent"
    else
        exec_args+=" --no-agent"
    fi
    
    cat > "${SYSTEMD_DIR}/turing-screens.service" << EOF
[Unit]
Description=Turing Smart Screen System Monitor
After=network.target

[Service]
Type=simple
ExecStart=${INSTALL_DIR}/turing-screens ${exec_args}
Restart=on-failure
RestartSec=5
User=root

# Security hardening
NoNewPrivileges=yes
ProtectSystem=strict
ProtectHome=read-only
PrivateTmp=yes

[Install]
WantedBy=multi-user.target
EOF
    
    systemctl daemon-reload
    log_success "Installed ${SYSTEMD_DIR}/turing-screens.service"
}

# Enable and start service
enable_service() {
    log_info "Enabling service..."
    systemctl enable turing-screens.service
    log_success "Service enabled"
    
    read -rp "Start service now? [y/N]: " start_now
    if [[ "$start_now" =~ ^[Yy] ]]; then
        systemctl start turing-screens.service
        sleep 2
        if systemctl is-active --quiet turing-screens.service; then
            log_success "Service started successfully"
        else
            log_error "Service failed to start. Check: journalctl -u turing-screens.service"
        fi
    fi
}

# Uninstall
uninstall() {
    check_root
    
    log_info "Uninstalling Turing Smart Screen..."
    
    # Stop and disable service
    if systemctl is-active --quiet turing-screens.service 2>/dev/null; then
        systemctl stop turing-screens.service
        log_success "Service stopped"
    fi
    
    if systemctl is-enabled --quiet turing-screens.service 2>/dev/null; then
        systemctl disable turing-screens.service
        log_success "Service disabled"
    fi
    
    # Remove files
    rm -f "${SYSTEMD_DIR}/turing-screens.service"
    rm -f "${UDEV_DIR}/99-turing-lcd.rules"
    rm -f "${INSTALL_DIR}/turing-screens"
    
    # Reload
    systemctl daemon-reload
    udevadm control --reload-rules
    udevadm trigger
    
    log_success "Uninstallation complete"
}

# Main installation
install() {
    check_root
    
    echo
    echo "╔═══════════════════════════════════════════════════════╗"
    echo "║     Turing Smart Screen Installer for Arch Linux      ║"
    echo "╚═══════════════════════════════════════════════════════╝"
    echo
    
    # Step 1: Detect and configure devices
    if ! configure_udev; then
        log_error "No devices configured. Connect displays and retry."
        exit 1
    fi
    
    echo
    
    # Step 2: Install binary
    install_binary
    
    # Step 3: Install systemd service
    install_service
    
    # Step 4: Enable service
    enable_service
    
    echo
    log_success "Installation complete!"
    echo
    echo "Commands:"
    echo "  sudo systemctl status turing-screens   # Check status"
    echo "  sudo systemctl restart turing-screens  # Restart"
    echo "  sudo journalctl -u turing-screens -f   # View logs"
    echo
}

# Parse arguments
case "${1:-}" in
    --uninstall)
        uninstall
        ;;
    --detect)
        detect_devices
        ;;
    *)
        install
        ;;
esac
